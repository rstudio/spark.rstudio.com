{
  "hash": "14a87a397e80061abc7734e37432d10e",
  "result": {
    "markdown": "---\ntitle: \"Text modeling\"\nexecute:\n  eval: true\n  freeze: true\n---\n\n\n\n\nThis article builds on the concepts and techniques contained in other articles found on this site. The example contained here goes beyond the *descriptive analysis* found in the [Text Mining](textmining.qmd) article. It shows how to pre-process, and then *model* text data. This article also expands on [ML Pipelines](pipelines.qmd), by providing more \"real life\" scenario of how and why to use pipelines.\n\n## Data\n\nThis article uses text data from the `modeldata` package. The *Fine foods example* data contains reviews of fine foods from Amazon. The package contains a training and a test set. The data consist of a product code, the text of the review, and the score. The score has two values: \"great\", and \"other\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(modeldata)\n\ndata(\"small_fine_foods\")\n\ntraining_data %>% \n  head(1) %>% \n  as.list()\n#> $product\n#> [1] \"B000J0LSBG\"\n#> \n#> $review\n#> [1] \"this stuff is  not stuffing  its  not good at all  save your money\"\n#> \n#> $score\n#> [1] other\n#> Levels: great other\n```\n:::\n\n\nWe will start by starting a local session of Spark, and then copying both data sets to our new session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sparklyr)\n\nsc <- spark_connect(master = \"local\", version = \"3.3\")\n\nsff_training_data <- copy_to(sc, training_data)\n\nsff_testing_data <- copy_to(sc, testing_data)\n```\n:::\n\n\n## Text transformers\n\n### Split into words (tokenizer)\n\nWe will split each review into individual words, or tokens. The `ft_tokenizer()` function returns a in-line list containing the individual words.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_training_data %>% \n  ft_tokenizer(\n    input_col = \"review\",\n    output_col = \"word_list\"\n  ) %>% \n  select(3:4)\n#> # Source: spark<?> [?? x 2]\n#>    score word_list   \n#>    <chr> <list>      \n#>  1 other <list [17]> \n#>  2 great <list [100]>\n#>  3 great <list [106]>\n#>  4 great <list [36]> \n#>  5 great <list [18]> \n#>  6 great <list [30]> \n#>  7 other <list [87]> \n#>  8 great <list [54]> \n#>  9 great <list [59]> \n#> 10 great <list [44]> \n#> # … with more rows\n```\n:::\n\n\n### Clean-up words (stop words)\n\nThere are words very common in text, words such as: \"the\", \"and\", \"or\", etc. These are called \"stop words\". Most often, stop words are not useful in analysis and modeling, so it is necessary to remove them. That is exactly what `ft_stop_words_remover()` does. In addition to English, Spark has lists of stop words for several other languages. In the resulting table, notice that the number of words in the `wo_stop_words` is lower than the `word_list`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_training_data %>% \n  ft_tokenizer(\n    input_col = \"review\",\n    output_col = \"word_list\"\n  ) %>% \n  ft_stop_words_remover(\n    input_col = \"word_list\", \n    output_col = \"wo_stop_words\"\n    ) %>% \n  select(3:5) \n#> # Source: spark<?> [?? x 3]\n#>    score word_list    wo_stop_words\n#>    <chr> <list>       <list>       \n#>  1 other <list [17]>  <list [9]>   \n#>  2 great <list [100]> <list [61]>  \n#>  3 great <list [106]> <list [67]>  \n#>  4 great <list [36]>  <list [20]>  \n#>  5 great <list [18]>  <list [9]>   \n#>  6 great <list [30]>  <list [17]>  \n#>  7 other <list [87]>  <list [58]>  \n#>  8 great <list [54]>  <list [33]>  \n#>  9 great <list [59]>  <list [36]>  \n#> 10 great <list [44]>  <list [24]>  \n#> # … with more rows\n```\n:::\n\n\n### Index words (hash)\n\nText hashing maps a sequence of words, or \"terms\", to their frequencies. The number of terms that are mapped can be controlled using the `num_features` argument in `ft_hashing_ft()`. Because we are eventually going to use a logistic regression model, we will need to override the frequencies from their original value to 1. This is accomplished by setting the `binary` argument to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_training_data %>%\n  ft_tokenizer(\n    input_col = \"review\",\n    output_col = \"word_list\"\n  ) %>% \n  ft_stop_words_remover(\n    input_col = \"word_list\", \n    output_col = \"wo_stop_words\"\n    ) %>% \n  ft_hashing_tf(\n    input_col = \"wo_stop_words\", \n    output_col = \"hashed_features\", \n    binary = TRUE, \n    num_features = 1024\n    ) %>%\n  select(3:6) \n#> # Source: spark<?> [?? x 4]\n#>    score word_list    wo_stop_words hashed_features\n#>    <chr> <list>       <list>        <list>         \n#>  1 other <list [17]>  <list [9]>    <dbl [1,024]>  \n#>  2 great <list [100]> <list [61]>   <dbl [1,024]>  \n#>  3 great <list [106]> <list [67]>   <dbl [1,024]>  \n#>  4 great <list [36]>  <list [20]>   <dbl [1,024]>  \n#>  5 great <list [18]>  <list [9]>    <dbl [1,024]>  \n#>  6 great <list [30]>  <list [17]>   <dbl [1,024]>  \n#>  7 other <list [87]>  <list [58]>   <dbl [1,024]>  \n#>  8 great <list [54]>  <list [33]>   <dbl [1,024]>  \n#>  9 great <list [59]>  <list [36]>   <dbl [1,024]>  \n#> 10 great <list [44]>  <list [24]>   <dbl [1,024]>  \n#> # … with more rows\n```\n:::\n\n\n### Normalize results\n\nFinally, we normalize the hashed column using `ft_normalizer()` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_training_data %>% \n  ft_tokenizer(\n    input_col = \"review\",\n    output_col = \"word_list\"\n  ) %>% \n  ft_stop_words_remover(\n    input_col = \"word_list\", \n    output_col = \"wo_stop_words\"\n    ) %>% \n  ft_hashing_tf(\n    input_col = \"wo_stop_words\", \n    output_col = \"hashed_features\", \n    binary = TRUE, \n    num_features = 1024\n    ) %>%\n  ft_normalizer(\n    input_col = \"hashed_features\", \n    output_col = \"normal_features\"\n    ) %>% \n  select(3:7) \n#> # Source: spark<?> [?? x 5]\n#>    score word_list    wo_stop_words hashed_features normal_features\n#>    <chr> <list>       <list>        <list>          <list>         \n#>  1 other <list [17]>  <list [9]>    <dbl [1,024]>   <dbl [1,024]>  \n#>  2 great <list [100]> <list [61]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  3 great <list [106]> <list [67]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  4 great <list [36]>  <list [20]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  5 great <list [18]>  <list [9]>    <dbl [1,024]>   <dbl [1,024]>  \n#>  6 great <list [30]>  <list [17]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  7 other <list [87]>  <list [58]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  8 great <list [54]>  <list [33]>   <dbl [1,024]>   <dbl [1,024]>  \n#>  9 great <list [59]>  <list [36]>   <dbl [1,024]>   <dbl [1,024]>  \n#> 10 great <list [44]>  <list [24]>   <dbl [1,024]>   <dbl [1,024]>  \n#> # … with more rows\n```\n:::\n\n\n::: callout-tip\n## Important concept\n\nThe `ft_hashing_tf()` outputs the index and frequency of each term. This can be thought of as how \"dummy variables\" are created for each discrete value of a categorical variable. This means that for modeling, we will only need to use only one \"column\", `hashed_features`. But, we will use `normal_features` for the model because it is derived from `hashed_features`.\n:::\n\n## Prepare the model with an ML Pipeline\n\nThe same set of complex transformations are needed for both modeling, and predictions. This means that we will have to duplicate the code for both. This is not ideal when developing, because any change in the transformation will have to be copied to both sets of code. This makes a compelling argument for using [ML Pipelines](pipelines.qmd).\n\nWe can initialize a pipeline (using `ml_pipeline()`), and then pass the same exact steps used in the previous section. We then append the model via `ft_r_formula()` and then the model function, in this case `ml_logistic_regression()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_pipeline <- ml_pipeline(sc) %>% \n  ft_tokenizer(\n    input_col = \"review\",\n    output_col = \"word_list\"\n  ) %>% \n  ft_stop_words_remover(\n    input_col = \"word_list\", \n    output_col = \"wo_stop_words\"\n    ) %>% \n  ft_hashing_tf(\n    input_col = \"wo_stop_words\", \n    output_col = \"hashed_features\", \n    binary = TRUE, \n    num_features = 1024\n    ) %>%\n  ft_normalizer(\n    input_col = \"hashed_features\", \n    output_col = \"normal_features\"\n    ) %>% \n  ft_r_formula(score ~ normal_features) %>% \n  ml_logistic_regression()  \n\nsff_pipeline\n#> Pipeline (Estimator) with 6 stages\n#> <pipeline__ce209e5f_f912_4f46_8b42_c736ca2ee338> \n#>   Stages \n#>   |--1 Tokenizer (Transformer)\n#>   |    <tokenizer__ba655c38_d06e_4e08_91c6_8a90cecbd95a> \n#>   |     (Parameters -- Column Names)\n#>   |      input_col: review\n#>   |      output_col: word_list\n#>   |--2 StopWordsRemover (Transformer)\n#>   |    <stop_words_remover__1cb9910b_4c33_439b_bbaf_08e2687b1442> \n#>   |     (Parameters -- Column Names)\n#>   |      input_col: word_list\n#>   |      output_col: wo_stop_words\n#>   |--3 HashingTF (Transformer)\n#>   |    <hashing_tf__a82904f8_7469_4c98_9635_3613780f7dbc> \n#>   |     (Parameters -- Column Names)\n#>   |      input_col: wo_stop_words\n#>   |      output_col: hashed_features\n#>   |--4 Normalizer (Transformer)\n#>   |    <normalizer__2c500991_221f_49a7_b07c_3b251b771837> \n#>   |     (Parameters -- Column Names)\n#>   |      input_col: hashed_features\n#>   |      output_col: normal_features\n#>   |--5 RFormula (Estimator)\n#>   |    <r_formula__60d2fcdc_3c54_4f3a_a687_60d35847b4fc> \n#>   |     (Parameters -- Column Names)\n#>   |      features_col: features\n#>   |      label_col: label\n#>   |     (Parameters)\n#>   |      force_index_label: FALSE\n#>   |      formula: score ~ normal_features\n#>   |      handle_invalid: error\n#>   |      stringIndexerOrderType: frequencyDesc\n#>   |--6 LogisticRegression (Estimator)\n#>   |    <logistic_regression__cce0e25a_e952_4c3b_9404_339309c28e6e> \n#>   |     (Parameters -- Column Names)\n#>   |      features_col: features\n#>   |      label_col: label\n#>   |      prediction_col: prediction\n#>   |      probability_col: probability\n#>   |      raw_prediction_col: rawPrediction\n#>   |     (Parameters)\n#>   |      aggregation_depth: 2\n#>   |      elastic_net_param: 0\n#>   |      family: auto\n#>   |      fit_intercept: TRUE\n#>   |      max_iter: 100\n#>   |      maxBlockSizeInMB: 0\n#>   |      reg_param: 0\n#>   |      standardization: TRUE\n#>   |      threshold: 0.5\n#>   |      tol: 1e-06\n```\n:::\n\n\n## Fit and predict\n\n`sff_pipeline` is an ML Pipeline, which is essentially a set of steps to take, can be think of akin to a `recipe`. In order to actually process de model we use `ml_fit()`. This executes all of the transformations, and then fits the model. In other words, `ml_fit()` runs all of the steps in the pipeline. The output will be considered an ML Pipeline Model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_pipeline_model <- ml_fit(sff_pipeline, sff_training_data)\n```\n:::\n\n\n`sff_pipeline_model` is more than just a \"fitted\" model. It also contains all of the pre-processing steps. So any new data passed through it, will go through the same transformations before running the predictions. To execute the pipeline model on against the test data, we use `ml_transform()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsff_test_predictions <- sff_pipeline_model %>% \n  ml_transform(sff_testing_data) \n\nglimpse(sff_test_predictions)\n#> Rows: ??\n#> Columns: 12\n#> Database: spark_connection\n#> $ product         <chr> \"B005GXFP60\", \"B000G7V394\", \"B004WJAULO\", \"B003D4MBOS\"…\n#> $ review          <chr> \"These are the best tasting gummy fruits I have ever e…\n#> $ score           <chr> \"great\", \"great\", \"other\", \"other\", \"great\", \"other\", …\n#> $ word_list       <list> [\"these\", \"are\", \"the\", \"best\", \"tasting\", \"gummy\", \"…\n#> $ wo_stop_words   <list> [\"best\", \"tasting\", \"gummy\", \"fruits\", \"ever\", \"eaten…\n#> $ hashed_features <list> <0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n#> $ normal_features <list> <0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000…\n#> $ features        <list> <0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000…\n#> $ label           <dbl> 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, …\n#> $ rawPrediction   <list> <8.570594, -8.570594>, <-0.1648486, 0.1648486>, <-1.9…\n#> $ probability     <list> <0.9998104359, 0.0001895641>, <0.4588809, 0.5411191>,…\n#> $ prediction      <dbl> 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, …\n```\n:::\n\n\nUsing `ml_metrics_binary()`, we can see how well the model performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_metrics_binary(sff_test_predictions)\n#> # A tibble: 2 × 3\n#>   .metric .estimator .estimate\n#>   <chr>   <chr>          <dbl>\n#> 1 roc_auc binary         0.706\n#> 2 pr_auc  binary         0.567\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
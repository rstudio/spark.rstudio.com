{
  "hash": "dc838cfd95113058629f1ee33aef4112",
  "result": {
    "markdown": "---\ntitle: \"Join Spark tbls.\"\nexecute:\n  freeze: true\n---\n\n\n\n\n*R/dplyr_join.R*\n\n## join.tbl_spark\n\n## Description\nThese functions are wrappers around their `dplyr` equivalents that set Spark SQL-compliant values for the `suffix` argument by replacing dots (`.`) with underscores (`_`). See [join] for a description of the general purpose of the functions. \n\n\n## Usage\n```r\n## S3 method for class 'tbl_spark'\ninner_join( \n  x, \n  y, \n  by = NULL, \n  copy = FALSE, \n  suffix = c(\"_x\", \"_y\"), \n  auto_index = FALSE, \n  ..., \n  sql_on = NULL \n) \n\n## S3 method for class 'tbl_spark'\nleft_join( \n  x, \n  y, \n  by = NULL, \n  copy = FALSE, \n  suffix = c(\"_x\", \"_y\"), \n  auto_index = FALSE, \n  ..., \n  sql_on = NULL \n) \n\n## S3 method for class 'tbl_spark'\nright_join( \n  x, \n  y, \n  by = NULL, \n  copy = FALSE, \n  suffix = c(\"_x\", \"_y\"), \n  auto_index = FALSE, \n  ..., \n  sql_on = NULL \n) \n\n## S3 method for class 'tbl_spark'\nfull_join( \n  x, \n  y, \n  by = NULL, \n  copy = FALSE, \n  suffix = c(\"_x\", \"_y\"), \n  auto_index = FALSE, \n  ..., \n  sql_on = NULL \n) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| x, y | A pair of lazy data frames backed by database queries. |\n| by | A character vector of variables to join by. <br>If `NULL`, the default, `*_join()` will perform a natural join, using all variables in common across `x` and `y`. A message lists the variables so that you can check they're correct; suppress the message by supplying `by` explicitly. <br>To join by different variables on `x` and `y`, use a named vector. For example, `by = c(\"a\" = \"b\")` will match `x$a` to `y$b`. <br>To join by multiple variables, use a vector with length > 1. For example, `by = c(\"a\", \"b\")` will match `x$a` to `y$a` and `x$b` to `y$b`. Use a named vector to match different variables in `x` and `y`. For example, `by = c(\"a\" = \"b\", \"c\" = \"d\")` will match `x$a` to `y$b` and `x$c` to `y$d`. <br>To perform a cross-join, generating all combinations of `x` and `y`, use `by = character()`. |\n| copy | If `x` and `y` are not from the same data source, and `copy` is `TRUE`, then `y` will be copied into a temporary table in same database as `x`. `*_join()` will automatically run `ANALYZE` on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. <br>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it. |\n| suffix | If there are non-joined duplicate variables in `x` and `y`, these suffixes will be added to the output to disambiguate them. Should be a character vector of length 2. |\n| auto_index | if `copy` is `TRUE`, automatically create indices for the variables in `by`. This may speed up the join if there are matching indexes in `x`. |\n| ... | Other parameters passed onto methods. |\n| sql_on | A custom join predicate as an SQL expression. Usually joins use column equality, but you can perform more complex queries by supply `sql_on` which should be a SQL expression that uses `LHS` and `RHS` aliases to refer to the left-hand side or right-hand side of the join respectively. |\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
---
title: "Model tuning"
execute:
  eval: true
  freeze: true
---


```{r setup}
#| include: false
library(sparklyr)
library(dplyr)
library(modeldata)
```

**Hyper parameter tuning**  is possible within Spark. `sparklyr` provides an interface
that makes it possible to setup, and run this kind of model tuning. 

This article walks through the basics of setting up and running a cross validation 
tuning run using the `cells` data from the `modeldata` package.

```{r}
data(cells, package = "modeldata")
```

The goal of the experiments in the example is to see at what point does the
number of trees in the model stop improving the accuracy of the predictions.  We
will have Spark run multiple iterations of the same model with an increasing
number of trees.

## Data setup

For this example, we will use a local connection, using Spark 3.3.

```{r}
library(sparklyr)

sc <- spark_connect(master = "local", version = "3.3")
```

The `cells` data is copied to the Spark session.

```{r}
tbl_cells <- copy_to(sc, cells, name = "cells_tbl")
```

We will split the data into two sets, "training" and "test".  The **test** split will
be treated as the "holdout" data to be used at the end of the process to confirm
that we did not over fit the model.

```{r}
tbl_cells_split <- tbl_cells %>% 
  select(-case) %>% 
  sdf_random_split(
    training = 0.8, 
    test = 0.2, 
    seed = 100
    )
```

## Cross validator prep

Preparing the cross validator requires three elements:

1. An [ML Pipeline](pipelines.qmd)
1. A `list` object containing the "grid", meaning the different parameters to test
1. An "evaluator" that will calculate the metrics of each model run

### Pipeline

In this example we will use a very simple pipeline. It will contain a
formula step and a Random Forest model.

```{r}
cells_pipeline <- sc %>% 
  ml_pipeline() %>%
  ft_r_formula(class ~ .) %>%
  ml_random_forest_classifier(seed = 207336481)

```

Each step within a pipeline receives a unique identifier. This identifier is
made up of the name of the step and a UID. The UID will change every time a new
pipeline is created. Here is an example of the out put for `cells_pipeline`:

```r
#> Pipeline (Estimator) with 2 stages
#> <pipeline__a1c04c2f_b955_4917_89b6_67cb576a779b> 
#>   Stages 
#>   |--1 RFormula (Estimator)
#>   |    <r_formula__043dd75a_7fd6_48bb_85c5_f20b321b97cb> 
#>   |     (Parameters -- Column Names)
#>   |      features_col: features
#>   |      label_col: label
#>   |     (Parameters)
#>   |      force_index_label: FALSE
#>   |      formula: class ~ .
#>   |      handle_invalid: error
#>   |      stringIndexerOrderType: frequencyDesc
#>   |--2 RandomForestClassifier (Estimator)
#>   |    <random_forest_classifier__52fc33ff_c4dc_44ac_b842_b873957db90a> 
#>   |     (Parameters -- Column Names)
#>   |      features_col: features
#>   |      label_col: label
#>   |      prediction_col: prediction
#>   |      probability_col: probability
#>   |      raw_prediction_col: rawPrediction
#>   |     (Parameters)
#>   |      bootstrap: TRUE
#>   |      cache_node_ids: FALSE
#>   |      checkpoint_interval: 10
#>   |      feature_subset_strategy: auto
#>   |      impurity: gini
#>   |      leafCol: 
#>   |      max_bins: 32
#>   |      max_depth: 5
#>   |      max_memory_in_mb: 256
#>   |      min_info_gain: 0
#>   |      min_instances_per_node: 1
#>   |      minWeightFractionPerNode: 0
#>   |      num_trees: 20
#>   |      seed: 207336481
#>   |      subsampling_rate: 1
```

### Grid

The way we can pass the parameters to try is via a simple `list` object. `sparklyr`
performs partial name matching to assign the list's entries to the `pipeline`
steps and the parameters.

The idea is to modify the **number of trees**  for each model run. From the output 
of the ML Pipeline above, we see that we need to modify the following:

```r
#>   |    <random_forest_classifier__52fc33ff_c4dc_44ac_b842_b873957db90a> 
#>   |                    ...
#>   |     (Parameters)
#>   |                    ...
#>   |      num_trees: 20
```

In R, we create the grid spec using the following: 

```{r}
cells_grid <- list(
  random_forest_classifier = list(  
    num_trees = 1:20 * 5
  )
)

cells_grid
```

Two things to highlight about the grid spec:

- `random_forest_classifier` is used to partially match to `random_forest_classifier__52fc33ff_c4dc_44ac_b842_b873957db90a` in the pipeline. It
is possible to pass the entire name, but that may prevent it from working if
a new pipeline is used. A new pipeline will have a different UID.
- For `num_trees` we passed a vector of 20 values to test with

### "Evaluator"

A metric will have to be calculated for each validation set in the folds. The 
model tuning function requires for that to be explicitly defined as an argument
(`ml_cross_validator()`).  There are multiple outcomes on the `class` field in the
`tbl_cells` table, this means that we will use `ml_multiclass_classification_evaluator()` for our 
validation function.

```{r}
cells_evaluator <- ml_multiclass_classification_evaluator(
  x = sc,
  metric_name = "accuracy"
  )
```


The "evaluator" function to use is based on the type of model that is being used
for tuning. Here is the list of the available "evaluator" functions in `sparklyr`:

- [`ml_binary_classification_evaluator()`](/packages/sparklyr/latest/reference/ml_evaluator.qmd)
- [`ml_binary_classification_eval()`](/packages/sparklyr/latest/reference/ml_evaluator.qmd)
- [`ml_multiclass_classification_evaluator()`](/packages/sparklyr/latest/reference/ml_evaluator.qmd)
- [`ml_classification_eval()`](/packages/sparklyr/latest/reference/ml_evaluator.qmd)
- [`ml_regression_evaluator()`](/packages/sparklyr/latest/reference/ml_evaluator.qmd)

## Model tuning

All the preparations steps come together now as arguments of `ml_cross_validator()`.
There are two additional arguments to consider:

- `num_folds`: The number of folder for the cross validation. The higher the
number, the longer it will take to complete. 
- `parallelism`: The number of threads to use when running parallel algorithms. 
Default is 1 for serial execution.

In this example,  `cells_pipeline`, `cells_grid`, and `cells_evaluator` are
passed to the respective arguments.

```{r}
cells_cv <- ml_cross_validator(
  x = sc,
  estimator = cells_pipeline, 
  estimator_param_maps = cells_grid,
  evaluator = cells_evaluator,
  num_folds = 5,
  parallelism = 4
)

cells_cv
```

The `ml_fit()` function will actually run the model tuning. This is where the
**training** split of the data is used.

```{r}
model_cv <- ml_fit(
  x = cells_cv, 
  dataset = tbl_cells_split$training
  )
```

## Validation metrics

The `ml_validation_metrics()` function will extract the metrics from each of the
values passed for **number of trees** parameter. If more than one parameter would
have been used, the number of results would be the total number of combinations.

```{r}
cv_metrics <- ml_validation_metrics(model_cv)

cv_metrics
```

For easier selection, we can use a quick plot to visualize how accuracy improves
as more trees are used, and when does the benefit plateau.

```{r}
#| warnings: false
#| message: false

library(ggplot2)

cv_metrics %>% 
  ggplot(aes(num_trees_1, accuracy)) +
  geom_line() +
  geom_smooth()
```

## Model selection 

As seen in the previous section, 50 trees seems to be a good number to use. To
finalize, a new model is fit, using that number for `num_trees`.  

A Model pipeline or a regular model could be used to do this. For this example 
we will just use the single step of fitting a new model using 
`ml_random_forest_classifier()` directly.

```{r}
cell_model <- ml_random_forest_classifier(
  tbl_cells_split$training, 
  class ~ ., 
  num_trees = 50
  )
```

## Test data metrics

The final step is to confirm that the model is not over-fitted. We use the new
model against the **test** split, and then piping it to `ml_metrics_multiclass()`
to confirm that the accuracy is within the expected range.

```{r}
cell_model %>% 
  ml_predict(tbl_cells_split$test) %>% 
  ml_metrics_multiclass()
```

## Tuning beyond model parameters

This example exp

```{r}
data("small_fine_foods")

sff_training_data <- copy_to(sc, training_data)

sff_testing_data <- copy_to(sc, testing_data)
```

```{r}
sff_pipeline <- sc %>% 
  ml_pipeline() %>% 
  ft_tokenizer("review", "word_list") %>% 
  ft_stop_words_remover("word_list", "wo_stop_words") %>% 
  ft_hashing_tf("wo_stop_words", "hashed_features", binary = TRUE) %>% 
  ft_normalizer("hashed_features", "normal_features") %>% 
  ft_r_formula(score ~ normal_features) %>% 
  ml_logistic_regression()

sff_pipeline
```

```r
Pipeline (Estimator) with 6 stages
<pipeline__0586a2aa_3aa2_4cdc_ab4c_4b2eb941ba75> 
  Stages 
  |--1 Tokenizer (Transformer)
  |    <tokenizer__a9f4bd41_a86c_47a3_b27a_ac372cd15c5e> 
  |     (Parameters -- Column Names)
  |      input_col: review
  |      output_col: word_list
  |--2 StopWordsRemover (Transformer)
  |    <stop_words_remover__5c180cbf_8e05_4ed2_a94b_0573f1362395> 
  |     (Parameters -- Column Names)
  |      input_col: word_list
  |      output_col: wo_stop_words
  |--3 HashingTF (Transformer)
  |    <hashing_tf__d4b70bde_add9_4fff_8564_454fef57ecc0> 
  |     (Parameters -- Column Names)
  |      input_col: wo_stop_words
  |      output_col: hashed_features
  |--4 Normalizer (Transformer)
  |    <normalizer__1641c9d1_a32b_482c_aed7_411f0cb6fb45> 
  |     (Parameters -- Column Names)
  |      input_col: hashed_features
  |      output_col: normal_features
  |--5 RFormula (Estimator)
  |    <r_formula__ea0e734a_da68_4449_b8f3_c12cc43027ec> 
  |     (Parameters -- Column Names)
  |      features_col: features
  |      label_col: label
  |     (Parameters)
  |      force_index_label: FALSE
  |      formula: score ~ normal_features
  |      handle_invalid: error
  |      stringIndexerOrderType: frequencyDesc
  |--6 LogisticRegression (Estimator)
  |    <logistic_regression__3e723f21_273b_46c3_b3b9_ced6452e3ea2> 
  |     (Parameters -- Column Names)
  |      features_col: features
  |      label_col: label
  |      prediction_col: prediction
  |      probability_col: probability
  |      raw_prediction_col: rawPrediction
  |     (Parameters)
  |      aggregation_depth: 2
  |      elastic_net_param: 0
  |      family: auto
  |      fit_intercept: TRUE
  |      max_iter: 100
  |      maxBlockSizeInMB: 0
  |      reg_param: 0
  |      standardization: TRUE
  |      threshold: 0.5
  |      tol: 1e-06
```

```{r}
sff_grid <-  list(
    hashing_tf = list(
      num_features = 2^c(8, 10, 12)  
    ),
    logistic_regression = list(
      elastic_net_param = 10^seq(-3, 0, length = 20), # penalty
      reg_param = seq(0, 1, length = 5) # mixture      
    )
  )

sff_grid
```

```r
$hashing_tf
$hashing_tf$num_features
[1]  256 1024 4096


$logistic_regression
$logistic_regression$elastic_net_param
 [1] 0.001000000 0.001438450 0.002069138 0.002976351 0.004281332 0.006158482 0.008858668
 [8] 0.012742750 0.018329807 0.026366509 0.037926902 0.054555948 0.078475997 0.112883789
[15] 0.162377674 0.233572147 0.335981829 0.483293024 0.695192796 1.000000000

$logistic_regression$reg_param
[1] 0.00 0.25 0.50 0.75 1.00

```

```{r}
sff_evaluator <- ml_binary_classification_evaluator(x = sc)
```


```{r}
sff_cv <- ml_cross_validator(
  x = sc,
  estimator = sff_pipeline, 
  estimator_param_maps = sff_grid,
  evaluator = sff_evaluator,
  num_folds = 5,
  parallelism = 4
)

sff_cv
```

```r
CrossValidator (Estimator)
<cross_validator__8f7ea300_d0e8_465f_96e9_2510b017b798> 
 (Parameters -- Tuning)
  estimator: Pipeline
             <pipeline__60426912_5b39_49ba_8e2e_350a97bf3a42> 
  evaluator: BinaryClassificationEvaluator
             <binary_classification_evaluator__6397a2f9_3a2b_4eec_aa2b_0b7712d2e201> 
    with metric areaUnderROC 
  num_folds: 5 
  [Tuned over 300 hyperparameter sets]
```
```{r}
sff_model <- ml_fit(
  x = sff_cv, 
  dataset = sff_training_data
  )
```

```{r}
sff_metrics <- ml_validation_metrics(sff_model)

sff_metrics
```
```
areaUnderROC
<dbl>
elastic_net_param_1
<dbl>
reg_param_1
<dbl>
num_features_2
<int>
0.6893548	0.001000000	0.00	256	
0.6893548	0.001438450	0.00	256	
0.6893548	0.002069138	0.00	256	
0.6893548	0.002976351	0.00	256	
0.6893548	0.004281332	0.00	256	
0.6893548	0.006158482	0.00	256	
0.6893548	0.008858668	0.00	256	
0.6893548	0.012742750	0.00	256	
0.6893548	0.018329807	0.00	256	
0.6893548	0.026366509	0.00	256	
```

```{r}
library(ggplot2)

sff_metrics %>% 
  mutate(reg_param_1 = as.factor(reg_param_1)) %>% 
  ggplot() +
  geom_line(aes(elastic_net_param_1, areaUnderROC, color = reg_param_1)) +
  facet_wrap(~ num_features_2) +
  theme_light()
```
```{r}
library(dplyr)

sff_metrics %>% 
  arrange(desc(areaUnderROC))
```
```{r}
new_sff_pipeline <- sc %>% 
  ml_pipeline() %>% 
  ft_tokenizer("review", "word_list") %>% 
  ft_stop_words_remover("word_list", "wo_stop_words") %>% 
  ft_hashing_tf("wo_stop_words", "hashed_features", binary = TRUE, num_features = 4096) %>% 
  ft_normalizer("hashed_features", "normal_features") %>% 
  ft_r_formula(score ~ normal_features) %>% 
  ml_logistic_regression(elastic_net_param = 0.018, reg_param = 0.5)

new_sff_fitted <- new_sff_pipeline %>% 
  ml_fit(sff_training_data)
```

```{r}
new_sff_fitted %>% 
  ml_transform(sff_testing_data) %>% 
  ml_metrics_binary()
```

```{r}
#| include: false
spark_disconnect(sc)
```




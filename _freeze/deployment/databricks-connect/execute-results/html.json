{
  "hash": "a74941d664fc4a7d152ea36664ca61d7",
  "result": {
    "markdown": "---\ntitle: Databricks Connect v2\nformat:\n  html:\n    theme: default\n    toc: true\nexecute:\n    eval: true\n    freeze: true\neditor: \n  markdown: \n    wrap: 72\naliases:\n  - /examples/databricks-cluster\n  - /examples/databricks-cluster-odbc.html  \n  - /examples/databricks-cluster-local.html\n  - /examples/databricks-cluster-remote.html\n  - /deployment/databricks-cluster.html\n  - /deployment/databricks-cluster-odbc.html  \n  - /deployment/databricks-cluster-local.html\n  - /deployment/databricks-cluster-remote.html\n  - /deployment/databricks-spark-connect.html  \n---\n\n\n\n\n*Last updated: Fri Dec  8 18:02:38 2023*\n\n## Intro\n\nDatabricks Connect enables the interaction with Spark clusters remotely.\nIt is based on Spark Connect, which enables remote connectivity thanks\nto its new decoupled client-server architecture. This allows users to\ninteract with the Spark cluster without having to run the jobs from a\nnode. Additionally, it removes the requirement of having Java components\ninstalled in the use's machine.\n\nThe API is very different than the \"legacy\" Spark, using the Spark shell\nis no longer an option. We have decided to use Python as the new\ninterface. In turn, Python uses *gRPC* to interact with Spark.\n\n::: {#fig-connect}\n\n```{mermaid}\n%%| fig-width: 10\n%%| eval: true\nflowchart LR\n  subgraph lp[test]\n    subgraph r[R]\n      sr[sparklyr]\n      rt[reticulate]\n    end\n    subgraph ps[Python]\n      dc[Databricks Connect]\n      g1[gRPC]\n    end\n  end   \n  subgraph db[Databricks]\n    sp[Spark]   \n  end\n  sr <--> rt\n  rt <--> dc\n  g1 <-- Internet<br>Connection --> sp\n  dc <--> g1\n  \n  style r   fill:#fff,stroke:#666,color:#000\n  style sr  fill:#fff,stroke:#666,color:#000\n  style rt  fill:#fff,stroke:#666,color:#000\n  style ps  fill:#fff,stroke:#666,color:#000\n  style lp  fill:#fff,stroke:#666,color:#fff\n  style db  fill:#fff,stroke:#666,color:#000\n  style sp  fill:#fff,stroke:#666,color:#000\n  style g1  fill:#fff,stroke:#666,color:#000\n  style dc  fill:#fff,stroke:#666,color:#000\n```\n\n\nHow `sparklyr` communicates with Databricks Connect\n:::\n\nWe are using `reticulate` to interact with the Python API. `sparklyr`\nextends the functionality, and user experience, by providing the\n`dplyr`back-end, `DBI` back-end, RStudio's Connection pane integration.\n\nIn order to quickly iterate on enhancements and bug fixes, we have\ndecided to isolate the Python integration into its own package. The new\npackage, called `pysparklyr`, is an extension of `sparklyr`.\n\n## Getting Started\n\n### Package Installation\n\nTo access Databricks Connect, you will need the following two packages:\n\n-   `sparklyr` - 1.8.4\n-   `pysparklyr` - 0.1.2\n\n``` r\ninstall.packages(\"sparklyr\")\ninstall.packages(\"pysparklyr\")\n```\n\n### Setup credentials\n\nTo use with Databricks Connect, in run-time 13 or above, you will need\nthree configuration items:\n\n1.  Your [Workspace Instance\n    URL](https://docs.databricks.com/workspace/workspace-details.html#workspace-url)\n2.  Your [Personal Authentication\n    Token](https://docs.databricks.com/dev-tools/auth.html#pat) (PAT)\n3.  Your\n    [cluster's](https://docs.databricks.com/workspace/workspace-details.html#cluster-url-and-id)\n    ID\n\nWe have developed this solution to align with other R, and non-R,\napplications that integrate with Databricks. All applications need, at\nminimum, a work space *(1)*, and the authentication token *(2)*. For\ndefault values, those applications initially look for these environment\nvariables:\n\n-   `DATABRICKS_HOST` - Your Workspace Instance URL\n-   `DATABRICKS_TOKEN` - Your Personal Authentication Token\n\nEnvironment variables work well, because they rarely vary between\nprojects. The thing that will change more often is the cluster you are\nconnecting to. It also makes connection safer, because the token's\ncontents will not be in your code in plain text. We recommend that you\nset these two variables at your **user level**. To do this run:\n\n``` r\nusethis::edit_r_environ()\n```\n\nThat command will open a text file that controls the environment\nvariables at the **user level**. If missing, insert the entries for the\ntwo variables:\n\n``` bash\nDATABRICKS_HOST=\"Enter here your Workspace URL\"\nDATABRICKS_TOKEN=\"Enter here your personal token\"\n```\n\n**This is a one time operation.** After saving and closing the file,\nrestart your R session.\n\n### First time connecting\n\nAfter setting up your Host and Token environment variables, you can now\nconnect to your cluster by simply providing the cluster's ID, and the\nmethod to `spark_connect()`:\n\n``` r\nlibrary(sparklyr)\n\nsc <- spark_connect(\n  cluster_id = \"Enter here your cluster ID\",\n  method = \"databricks_connect\"\n)\n```\n\nIn order to connect and interact with Databricks, you will need a\nspecific set of [Python libraries](#python-libraries) installed and\navailable. To make it easier to get started, we provide functionality\nthat will automatically do the following:\n\n-   Create, or re-create, a Python environment. Based on your OS, it\n    will choose to create a Virtual Environment, or Conda.\n\n-   Install the needed Python libraries\n\n`spark_connect()` will check to see if you have the expected Python\nenvironment, and prompt you to accept its installation if missing. Here\nis an example of the code and output you would expect to see:\n\n``` r\nsc <- spark_connect(\n    cluster_id = \"1026-175310-7cpsh3g8\",\n    method = \"databricks_connect\"\n)\n\n#> ! Retrieving version from cluster '1026-175310-7cpsh3g8' \n#> Cluster version: '14.1' \n#> ! No viable Python Environment was identified for Databricks Connect version 14.1 \n#> Do you wish to install Databricks Connect version 14.1? \n#>  \n#> 1: Yes \n#> 2: No \n#> 3: Cancel \n#>  \n#> Selection: 1 \n```\n\nAfter accepting, the Python environment will be created with a specific\nname, and all of the needed Python libraries will be installed within.\nAfter it is done, it will attempt to connect to your cluster. Here is an\nabbreviated example of the output that occurs when selecting \"Yes\":\n\n``` r\n#> ✔ Automatically naming the environment:'r-sparklyr-databricks-14.1' \n#> Using Python: /Users/edgar/.pyenv/versions/3.10.13/bin/python3.10 \n#> Creating virtual environment 'r-sparklyr-databricks-14.1' ... \n#> + /Users/edgar/.pyenv/versions/3.10.13/bin/python3.10 -m venv /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1 \n#> Done! \n#>   Installing packages: pip, wheel, setuptools \n#> + /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python -m pip install --upgrade pip wheel setuptools \n#> Requirement already satisfied: pip in /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/lib/python3.10/site-packages (23.0.1) \n#> Collecting pip \n#> Using cached pip-23.3.1-py3-none-any.whl (2.1 MB) \n#> Collecting wheel \n#> Using cached wheel-0.42.0-py3-none-any.whl (65 kB) \n#> Requirement already satisfied: setuptools in /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/lib/python3.10/site-packages (65.5.0) \n...\n...\n...\n#> Successfully installed PyArrow-14.0.1 cachetools-5.3.2 certifi-2023.11.17 charset-normalizer-3.3.2 databricks-connect-14.1.0 databricks-sdk-0.14.0 google-api-core-2.14.0 google-api-python-client-2.109.0 google-auth-2.25.0 google-auth-httplib2-0.1.1 googleapis-common-protos-1.61.0 grpcio-1.59.3 grpcio_status-1.59.3 httplib2-0.22.0 idna-3.6 numpy-1.26.2 pandas-2.1.3 protobuf-4.25.1 py4j-0.10.9.7 pyasn1-0.5.1 pyasn1-modules-0.3.0 pyparsing-3.1.1 python-dateutil-2.8.2 pytz-2023.3.post1 requests-2.31.0 rsa-4.9 six-1.16.0 tzdata-2023.3 uritemplate-4.1.1 urllib3-2.1.0 \n#> ✔ Using the 'r-sparklyr-databricks-14.1' Python environment \n#> Path: /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python \n```\n\n## Interacting with the cluster\n\n### RStudio's Connection pane\n\nThanks to the new way we are integrating with Spark, it is now possible\nto display the same structure displayed in the Databricks Data Explorer\npage. In Databricks, the current data structure levels are:\n\n-   Catalog\n    -   Database\n        -   Table\n\nIn RStudio, you can navigate the data structure by expanding from the\ntop level, all the way down to the table you wish to explore. Once\nexpanded, the table's fields, and their types are displayed.\n\n![](/images/deployment/connect/rstudio-connection.png)\n\nIn the Connection Pane, you can click on the **table** icon, situated to\nthe right of the table name, to preview the first 1,000 rows:\n\n![](/images/deployment/connect/preview.png)\n\n### Using the Connection to Access Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(dbplyr)\nlibrary(sparklyr)\n\nsc <- spark_connect(\n    cluster_id = \"1026-175310-7cpsh3g8\",\n    method = \"databricks_connect\"\n)\n#> ! Sanitizing Databricks Host (`master`) entry:\n#>   Original: rstudio-partner-posit-default.cloud.databricks.com\n#>   Using: https://rstudio-partner-posit-default.cloud.databricks.com\n#>   Set `host_sanitize = FALSE` in `spark_connect()` to avoid this change\n#> ! Retrieving version from cluster '1026-175310-7cpsh3g8'\n#>   Cluster version: '14.1'\n#> ✔ Using the 'r-sparklyr-databricks-14.1' Python environment\n#>   Path: /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python\n```\n:::\n\n\nAfter connecting, you can use `dbplyr`'s `in_catalog()` function to\naccess any table in your data catalog. You will only need to pass the\nrespective names of the three levels as comma separated character\nentries to `in_catalog()` in this order: Catalog, Database, and Table.\n\nHere is an example of using `tbl()` and `in_catalog()` to point to the\n**trips** table, which is inside **nyctaxi** database, which is a\ndatabase inside the **samples** catalog:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrips <- tbl(sc, in_catalog(\"samples\", \"nyctaxi\", \"trips\"))\n\ntrips\n#> # Source: spark<trips> [?? x 6]\n#>    tpep_pickup_datetime tpep_dropoff_datetime trip_distance fare_amount\n#>    <dttm>               <dttm>                        <dbl>       <dbl>\n#>  1 2016-02-14 10:52:13  2016-02-14 11:16:04            4.94        19  \n#>  2 2016-02-04 12:44:19  2016-02-04 12:46:00            0.28         3.5\n#>  3 2016-02-17 11:13:57  2016-02-17 11:17:55            0.7          5  \n#>  4 2016-02-18 04:36:07  2016-02-18 04:41:45            0.8          6  \n#>  5 2016-02-22 08:14:41  2016-02-22 08:31:52            4.51        17  \n#>  6 2016-02-05 00:45:02  2016-02-05 00:50:26            1.8          7  \n#>  7 2016-02-15 09:03:28  2016-02-15 09:18:45            2.58        12  \n#>  8 2016-02-25 13:09:26  2016-02-25 13:24:50            1.4         11  \n#>  9 2016-02-13 10:28:18  2016-02-13 10:36:36            1.21         7.5\n#> 10 2016-02-13 18:03:48  2016-02-13 18:10:24            0.6          6  \n#> # ℹ more rows\n#> # ℹ 2 more variables: pickup_zip <int>, dropoff_zip <int>\n```\n:::\n\n\nAfter pointing `tbl()` to that specific table, you can then use `dplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrips %>%\n  group_by(pickup_zip) %>%\n  summarise(\n    count = n(),\n    avg_distance = mean(trip_distance, na.rm = TRUE)\n  )\n#> # Source: spark<?> [?? x 3]\n#>    pickup_zip count avg_distance\n#>         <int> <dbl>        <dbl>\n#>  1      10032    15         4.49\n#>  2      10013   273         2.98\n#>  3      10022   519         2.00\n#>  4      10162   414         2.19\n#>  5      10018  1012         2.60\n#>  6      11106    39         2.03\n#>  7      10011  1129         2.29\n#>  8      11103    16         2.75\n#>  9      11237    15         3.31\n#> 10      11422   429        15.5 \n#> # ℹ more rows\n```\n:::\n\n\n## Machine Learning\n\nMachine Learning capabilities are currently available starting with\nDatabricks Runtime version 14.1. Compared to \"legacy\" Spark, Spark\nConnect's ML capabilities are limited. At this time, there is only one\nsupported model, Logistic Regression, and two scaler transformers,\nnamely Standard Scaler and Max Abs Scaler. `sparklyr` makes that\nfunctionality available.\n\n### Using for the first time\n\nBy default, the Python environment that `sparklyr` creates, does not\ninclude the libraries that relate to Machine Learning. These include\nTorch, and \"scikit-learn\". Some of the libraries are large in size, and\nsometimes they may have some Python requirements that may make it\nchallenging to new users. Additionally , we have noticed that, at this\ntime, there are not many users that need to utilize ML capabilities.\n\nThe first time an ML function is accessed through `sparklyr`, you will\nbe prompted to install the additional Python libraries which are needed\nto access such ML capabilities.\n\n``` r\nml_logistic_regression(tbl_mtcars, am ~ .)\n#> ! Required Python libraries to run ML functions are missing\n#>   Could not find: torch, torcheval, and scikit-learn\n#>   Do you wish to install? (This will be a one time operation)\n#> \n#> 1: Yes\n#> 2: Cancel\n#> \n#> Selection: 1\n#> Using virtual environment '/Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1' ...\n#> + /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python -m pip install --upgrade --no-user torch torcheval scikit-learn\n#> Collecting torch\n...\n```\n\n::: callout-note\nIt is possible to install the ML libraries along with the required\nlibraries. There may be several reasons to do this, including trying to\nrecreate the environment after upgrading Python in your machine. Just\npass `install_ml=TRUE` to the installation function:\n\n``` r\ninstall_databricks(cluster_id = \"Enter your cluster's ID\", install_ml = TRUE)\n```\n\nor\n\n``` r\ninstall_databricks(version = \"14.1\", install_ml = TRUE)\n```\n:::\n\n### Easily fit and use\n\nAt this time, Logistic Regression is the only model supported. As usual,\nthere are specific data preparation steps in order to run. `sparklyr`\nautomates those steps, so all you have to do is pass the Spark data\nframe, and the formula to use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_mtcars <- copy_to(sc, mtcars)\n\nmodel1 <- ml_logistic_regression(tbl_mtcars, am ~ .)\n```\n:::\n\n\nThe output for Spark Connect based models has been upgraded. It will\ndisplay the model parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel1\n#> \n#> ── ML Connect model:\n#> Logistic Regression\n#> \n#> ── Parameters:\n#> ◼ batchSize:       32            ◼ momentum:        0.9        \n#> ◼ featuresCol:     features      ◼ numTrainWorkers: 1          \n#> ◼ fitIntercept:    TRUE          ◼ predictionCol:   prediction \n#> ◼ labelCol:        label         ◼ probabilityCol:  probability\n#> ◼ learningRate:    0.001         ◼ seed:            0          \n#> ◼ maxIter:         100           ◼ tol:             1e-06\n```\n:::\n\n\nAs shown in the following screenshot, the new output features a\nfirst-of-its-kind tooltip, it will popup the description of the\nparameter when hovered over. This functionality works when used in\nRStudio, and any console that supports this kind of enhanced user\nexperience.\n\n![](/images/deployment/databricks/model-output.png)\n\nTo use the model, you can run `ml_predict()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_predict(model1, tbl_mtcars)\n#> # Source: spark<?> [?? x 13]\n#>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb prediction\n#>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>      <dbl>\n#>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4          0\n#>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4          0\n#>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1          1\n#>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1          0\n#>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2          0\n#>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1          0\n#>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4          0\n#>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2          0\n#>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2          0\n#> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4          1\n#> # ℹ more rows\n#> # ℹ 1 more variable: probability <chr>\n```\n:::\n\n\n### Using feature transformers\n\nThese are the two feature transformers currently supported:\n\n-   Standard Scaler - `ft_standard_scaler()`\n-   Max Abs Scaler - `ft_max_abs_scaler()`\n\nTo access simply call the function by passing a vector of column names.\nPlease note that it will create a single column with an array field that\ncontains all of the newly scaled values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_mtcars %>% \n  ft_standard_scaler(c(\"wt\", \"mpg\"), \"features\") %>% \n  select(wt, mpg, features)\n#> # Source: spark<?> [?? x 3]\n#>       wt   mpg features                                  \n#>    <dbl> <dbl> <chr>                                     \n#>  1  2.62  21   c(-0.610399567481535, 0.150884824647656)  \n#>  2  2.88  21   c(-0.349785269100972, 0.150884824647656)  \n#>  3  2.32  22.8 c(-0.917004624399845, 0.449543446630647)  \n#>  4  3.22  21.4 c(-0.00229953792688741, 0.217253407310543)\n#>  5  3.44  18.7 c(0.227654254761845, -0.230734525663943)  \n#>  6  3.46  18.1 c(0.248094591889732, -0.330287399658273)  \n#>  7  3.57  14.3 c(0.360516446093113, -0.960788934955698)  \n#>  8  3.19  24.4 c(-0.0278499593367465, 0.715017777282194) \n#>  9  3.15  22.8 c(-0.0687306335925211, 0.449543446630647) \n#> 10  3.44  19.2 c(0.227654254761845, -0.147773797335335)  \n#> # ℹ more rows\n```\n:::\n\n\nWhen you are done with you queries and computations, you should\ndisconnect from the cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspark_disconnect(sc)\n```\n:::\n\n\n## Reported Problems\n\nAs it is with any new implementations, we are seeing some early adopters\nreport issues with their installation or connections. Here are some of\nthe issues that have been reported to us, and the recommended solution,\nor workaround. Each issue is **collapsed**, just expand it to see the\nbackground and recommendation. Each one is titled based on the full\nerror message or, the distinctive part of the error message.\n\nBefore reviewing the issues, please make sure to have the latest\nversions of `sparklyr`, and `pysparklyr` from CRAN. These are the\ncurrent version levels:\n\n-   `sparklyr` - 1.8.4\n-   `pysparklyr` - 0.1.2\n\n::: {.callout-note collapse=\"true\"}\n## `...reticulate can only bind to copies of Python built with '--enable-shared'.`\n\nError message contains:\n\n``` r\n... reticulate can only bind to copies of Python built with '--enable-shared'.\n```\n\nThis is happening because there is no Python installation that\n`reticulate` can use. `pysparklyr` depends on that package to function.\n\n### Solution\n\nThe best way to resolve is to install an acceptable version of Python.\nYou can run:\n\n``` r\nreticulate::install_python()\n```\n\nIf the output mentions `--skip-existing [version number]` then you will\nhave two options:\n\n1.  If you're ok with replacing the existing Python, then use:\n\n    ``` r\n     reticulate::install_python(version = \"[version number]\", force = TRUE)\n    ```\n\n2.  If you would like to keep that installation of Python then use a\n    different version number:\n\n    ``` r\n     reticulate::install_python(version = \"[slightly different version number]\")\n    ```\n\n    For example, if the version number is `3.9.12`, then use `3.9.18`:\n\n    ``` r\n    reticulate::install_python(version = \"3.9.18\")\n    ```\n:::\n\n::: {.callout-note collapse=\"true\"}\n## `spark_connect()` returns `! Version '14.2' does not exist`\n\nError message contains:\n\n``` r\n  Checking if provided version is valid against PyPi.org\n  Error in `install_environment()`\n  ! Version '14.2' does not exist\n```\n\nThis happens when `pysparklyr` gets the cluster DBR version\nautomatically. Usually when running `spark_connect()` or\n`install_databricks()`. This occurs because the latest version of DBR,\nas of today 14.2, is ahead of what the `databricks.connect` version\navailable in `databricks.connect`.\n\n### Solution\n\nCurrent workaround is to say \"No\" when prompted to install version 14.2.\nAnd if missing in your machine, install 14.1 using:\n\n``` r\npysparklyr::install_databricks(\"14.1\")\n```\n:::\n\n## Environments\n\n### Install different version of `databricks.connect`\n\nHere are three different options to create a custom Python environment,\nthat will contain the needed Python libraries to interact with\nDatabricks Connect:\n\n-   To install the latest versions of all the needed libraries, use:\n\n    ``` r\n    pysparklyr::install_databricks()\n    ```\n\n    `sparklyr` will query PyPi.org to get the latest version of\n    `databricks.connect` and installs that version.\n\n-   It is recommended that the version of the `databricks.connect`\n    library, matches the DBR version of your cluster. To do this, pass\n    the DBR version in the `version` argument, for example:\n\n    ``` r\n    pysparklyr::install_databricks(\"14.0\")\n    ```\n\n    This will create a Python environment and install\n    `databricks.connect` version 14.0, and it will automatically name it\n    `r-sparklyr-databricks-14.0`. By using this name, `sparklyr` is able\n    to know what version of `databricks.connect` is available inside\n    this particular Python environment.\n\n-   If you are not sure about the version of the cluster you want to\n    interact with, then use the `cluster_id` argument. We have added a\n    way to pull the cluster's information, without starting a Spark\n    connect. This allows us to query the cluster and get the DBR\n    version:\n\n    ``` r\n    pysparklyr::install_databricks(cluster_id = \"[Your cluster's ID]\")\n    ```\n\n### Restricted Python environments\n\nIf your organization restricts Python environment creation, you can\npoint `sparklyr` to the designated Python installation. To do this, pass\nthe path to the environment in the `envname` argument of\n`spark_connect()`:\n\n``` r\nlibrary(sparklyr)\n\nsc <- spark_connect(\n  method = \"databricks_connect\",\n  cluster_id = \"Enter here your cluster ID\",\n  envname = \"Enter here the path to your Python environment\"\n)\n```\n\nTo successfully connect to a Databricks cluster, you will need to match\nthe proper version of the `databricks.connect` Python library, to the\nDatabricks Runtime (DBR) version in the cluster. For example, if you are\ntrying to use a Databricks cluster with a DBR version 14.0, then\n`databricks.connect` will also need to be version 14.0. Failure to do\nso, can result in instability, or even the inability to connect.\n\nBesides `datbricks.connect`, the Python environment will also need to\nhave other Python libraries installed. The full list is in the [Python\nLibraries](#python-libraries) section.\n\n::: callout-important\nIf your server, or machine, has only one Python installation and, no\nability to create Conda or Virtual environments, then you will encounter\nissues when connecting to a Databricks cluster with a mismatched version\nof `databricks.connect` to DBR.\n:::\n\n**Important** - This step needs only to be **done one time**. If you\nneed to connect to a different cluster, but that has the same DBR\nversion, `sparklyr` will use the same Python environment. If the new\ncluster has a different DBR version, then it is recommended that you run\nthe installation function using the new DBR version, or cluster ID.\n\n### Python Libraries {#python-libraries}\n\nHere is the list of the Python libraries needed in order to work with\nthe cluster:\n\nRequired libraries:\n\n-   `databricks-connect`\n-   `delta-spark`\n-   `pandas`\n-   `PyArrow`\n-   `grpcio`\n-   `google-api-python-client`\n-   `grpcio_status`\n\nML libraries (Optional):\n\n-   `torch`\n-   `torcheval`\n-   `scikit-learn`\n\n## Deploying to Posit Connect\n\nWe recommend that for simply accessing data from the Unity Catalog, such\nas in a Shiny app, use an ODBC connection instead of a Spark session.\nThe advantage of this, is that a connection to the Databricks Warehouse\ndoes not require a running cluster. For more information about creating\ndashboards with databases visit [Database with R\nsite](https://solutions.posit.co/connections/db/best-practices/dashboards/).\n\nHowever, there are cases when it is necessary to deploy a solution that\nrequires a Spark session. For example, when there is a long running job\nthat needs to run on a schedule. Those kinds of jobs could be put inside\na Quarto document, and published to Posit Connect, where they can run on\nspecific date/time intervals. Posit Connect supports Python\nenvironments, so it is an ideal platform to deploy these kinds of\nsolutions.\n\n### Preparing for deployment\n\nWhen deploying to Posit Connect, there are specific pieces of\ninformation that we need to make sure are sent over:\n\n-   Your **cluster's ID**\n-   Your **workspace URL**\n-   Your **token**\n-   Your **Python environment**'s location\n-   To use the `pysparklyr` extension\n\nBased on the recommendations in this article, the **cluster's ID**\nshould be in the code of your document, the **workspace URL** and\n**token** should already be inside the `DATABRICKS_HOST`, and\n`DATABRICKS_TOKEN` environment variables.\n\nMake sure that your document has a `library(pysparklyr`) call. This will\nlet Posit Connect deployment process know that it needs to install this\npackage, and its dependencies, such as `reticulate`.\n\nThe Python environment location can be copied from the output of\n`spark_connect()`. In the following example, you can see how we are\nloading `pysparklyr`. Note that at the bottom of the output from\n`spark_connect()`, the **path** to your local Python environment is\ndisplayed, copy this path. The next section will explain why this is\nimportant to retain.\n\n``` r\nlibrary(sparklyr)\nlibrary(pyspaklyr)\n\nsc <- spark_connect(\n    cluster_id = \"1026-175310-7cpsh3g8\",\n    method = \"databricks_connect\"\n)\n#> ! Retrieving version from cluster '1026-175310-7cpsh3g8'\n#>   Cluster version: '14.1'\n#> ✔ Using the 'r-sparklyr-databricks-14.1' Python environment\n#>   Path: /Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python <<-- COPY THIS\n```\n\n### Using `deployApp()`\n\nPosit Connect will recreate your Python environment so that any content,\nthat uses Python, works properly. Because we do not use the default\nPython environment to connect to Databricks, we need a way to tell Posit\nConnect which environment to recreate.\n\nAdditionally, to avoid changing the code we used to create the document,\nwe want to share with Posit Connect the contents of our Databricks\nenvironment variables.\n\nThe `deployApp()` function from the `rsconnect` package allows us to\neasily do all this:\n\n``` r\nrsconnect::deployApp(\n  python = \"Enter the Python environment to recreate\",\n  envVars = c(\"DATABRICKS_HOST\", \"DATABRICKS_TOKEN\"),\n  lint = FALSE\n)\n```\n\nIn the `python` argument, paste the value from the 'Path:' output\n`spark_connect()` used when you were testing your document locally. The\n`envVars` argument will let Posit Connect know to create those\nenvironment variables, and to use the values from your machine.\n\n**Important:** Please note that `deployApp()` is not called from inside\nyour document. It needs to be something you call outside, in your R\nconsole for example. If you wish to create an **R script** in your\nproject that contains your deployment call, **do not place it in the\nsame folder as your document**.\n\nHere is an sample of how a `deployApp()` call. There are some additional\nnotes, as code comments, to further explain how and why to use:\n\n``` r\nrsconnect::deployApp(\n  # Title to show for your document\n  appTitle = \"My cool document\", \n  # The path for your document within your project\n  appDir = here::here(\"cool-document\"),\n  # Pasted from previous section's output\n  python = \"/Users/edgar/.virtualenvs/r-sparklyr-databricks-14.1/bin/python\", \n  # Passing host and token environment variables\n  envVars = c(\"DATABRICKS_HOST\", \"DATABRICKS_TOKEN\"),\n  # Avoids unnecessary code check, leaving TRUE may cause issues such as this\n  # error: \"paths should be to files within the project directory\"\n  lint = FALSE\n)\n```\n\n## What is supported\n\nHere is a list of what we currently support, and do not support via\n`sparklyr` and Connect:\n\n**Supported**:\n\n-   Integration with most of the `dplyr`, and `DBI`, APIs\n-   Integration with the `invoke()` command\n-   RStudio Connections Pane navigation\n-   Support for Personal Access Token security authentication for\n    Databricks Connect\n-   Support for most read and write commands. These have only been\n    tested in Spark Connect.\n\n**Not supported**:\n\n-   **ML functions** - Very few functions, in `sparklyr`, that have the\n    `ml_` and `ft_` are currently not supported. The reason is that\n    Spark 3.4 does not currently support MLlib. We expect that some ML\n    support will be available in Spark 3.5. At that time we will work on\n    integrating the new ML routines from Connect into `sparklyr`.\n\n-   **SDF functions** - Most of these functions require SparkSession,\n    which is currently not supported in Spark 3.4.\n\n-   **`tidyr`** - This is ongoing work that we are focusing on in\n    `sparklyr`. We are implementing these functions using PySpark\n    DataFrame commands, instead of depending on the Scala\n    implementation.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
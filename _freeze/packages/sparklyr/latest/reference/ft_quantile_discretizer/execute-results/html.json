{
  "hash": "2075267ccaaa0002af75039bc0f7bec4",
  "result": {
    "markdown": "---\ntitle: \"Feature Transformation -- QuantileDiscretizer (Estimator)\"\nexecute:\n  freeze: true\n---\n\n\n\n\n*R/ml_feature_quantile_discretizer.R*\n\n## ft_quantile_discretizer\n\n## Description\n`ft_quantile_discretizer` takes a column with continuous features and outputs   a column with binned categorical features. The number of bins can be   set using the `num_buckets` parameter. It is possible that the number   of buckets used will be smaller than this value, for example, if there   are too few distinct values of the input to create enough distinct   quantiles. \n\n\n## Usage\n```r\nft_quantile_discretizer( \n  x, \n  input_col = NULL, \n  output_col = NULL, \n  num_buckets = 2, \n  input_cols = NULL, \n  output_cols = NULL, \n  num_buckets_array = NULL, \n  handle_invalid = \"error\", \n  relative_error = 0.001, \n  uid = random_string(\"quantile_discretizer_\"), \n  weight_column = NULL, \n  ... \n) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| x | A `spark_connection`, `ml_pipeline`, or a `tbl_spark`. |\n| input_col | The name of the input column. |\n| output_col | The name of the output column. |\n| num_buckets | Number of buckets (quantiles, or categories) into which data points are grouped. Must be greater than or equal to 2. |\n| input_cols | Names of input columns. |\n| output_cols | Names of output columns. |\n| num_buckets_array | Array of number of buckets (quantiles, or categories) into which data points are grouped. Each value must be greater than or equal to 2. |\n| handle_invalid | (Spark 2.1.0+) Param for how to handle invalid entries. Options are 'skip' (filter out rows with invalid values), 'error' (throw an error), or 'keep' (keep invalid values in a special additional bucket). Default: \"error\" |\n| relative_error | (Spark 2.0.0+) Relative error (see documentation for org.apache.spark.sql.DataFrameStatFunctions.approxQuantile [here](https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrameStatFunctions)<br>for description). Must be in the range [0, 1]. default: 0.001 |\n| uid | A character string used to uniquely identify the feature transformer. |\n| weight_column | If not NULL, then a generalized version of the Greenwald-Khanna algorithm will be run to compute weighted percentiles, with each input having a relative weight specified by the corresponding value in `weight_column`. The weights can be considered as relative frequencies of sample inputs. |\n| ... | Optional arguments; currently unused. |\n\n## Details\n\nNaN handling: null and NaN values will be ignored from the column   during `QuantileDiscretizer` fitting. This will produce a `Bucketizer`\n\n  model for making predictions. During the transformation, `Bucketizer`\n\n  will raise an error when it finds NaN values in the dataset, but the   user can also choose to either keep or remove NaN values within the   dataset by setting `handle_invalid` If the user chooses to keep NaN values,   they will be handled specially and placed into their own bucket,   for example, if 4 buckets are used, then non-NaN data will be put   into buckets[0-3], but NaNs will be counted in a special bucket[4]. \n\n  Algorithm: The bin ranges are chosen using an approximate algorithm (see   the documentation for org.apache.spark.sql.DataFrameStatFunctions.approxQuantile   [here](https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrameStatFunctions) for a detailed description). The precision of the approximation can be   controlled with the `relative_error` parameter. The lower and upper bin   bounds will be -Infinity and +Infinity, covering all real values. \n\n  Note that the result may be different every time you run it, since the sample   strategy behind it is non-deterministic. \n\nIn the case where `x` is a `tbl_spark`, the estimator fits against `x`\n\n  to obtain a transformer, which is then immediately used to transform `x`, returning a `tbl_spark`. \n\n\n## Value\n\nThe object returned depends on the class of `x`. \n\n  \n\n- `spark_connection`: When `x` is a `spark_connection`, the function returns a `ml_transformer`,   a `ml_estimator`, or one of their subclasses. The object contains a pointer to   a Spark `Transformer` or `Estimator` object and can be used to compose   `Pipeline` objects. \n\n  \n\n- `ml_pipeline`: When `x` is a `ml_pipeline`, the function returns a `ml_pipeline` with   the transformer or estimator appended to the pipeline. \n\n  \n\n- `tbl_spark`: When `x` is a `tbl_spark`, a transformer is constructed then   immediately applied to the input `tbl_spark`, returning a `tbl_spark`\n\n\n\n## See Also\n\nSee [https://spark.apache.org/docs/latest/ml-features.html](https://spark.apache.org/docs/latest/ml-features.html) for   more information on the set of transformations available for DataFrame   columns in Spark. \n\n`ft_bucketizer`\n\nOther feature transformers:  `ft_binarizer()`, `ft_bucketizer()`, `ft_chisq_selector()`, `ft_count_vectorizer()`, `ft_dct()`, `ft_elementwise_product()`, `ft_feature_hasher()`, `ft_hashing_tf()`, `ft_idf()`, `ft_imputer()`, `ft_index_to_string()`, `ft_interaction()`, `ft_lsh`, `ft_max_abs_scaler()`, `ft_min_max_scaler()`, `ft_ngram()`, `ft_normalizer()`, `ft_one_hot_encoder_estimator()`, `ft_one_hot_encoder()`, `ft_pca()`, `ft_polynomial_expansion()`, `ft_r_formula()`, `ft_regex_tokenizer()`, `ft_robust_scaler()`, `ft_sql_transformer()`, `ft_standard_scaler()`, `ft_stop_words_remover()`, `ft_string_indexer()`, `ft_tokenizer()`, `ft_vector_assembler()`, `ft_vector_indexer()`, `ft_vector_slicer()`, `ft_word2vec()`\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}